## 关键字

**register**

请求编译器尽可能将变量存在cpu内部寄存器中，而不通过内存寻址以提高效率，速度快。
其变量长度应小于等于整型长度。因其可能不存在内存中，所以不能用取址运算符`&`来获取register变量地址。

```c
register int i;
```

**static**

* 修饰变量

*静态全局变量*，作用域仅限于变量被定义的文件中，其他文件不可使用它。准确来说，作用域是从定义之处开始，到文件结尾处结束。

*静态局部变量*在函数体中定义。由于被static修饰的变量总存在内存的静态区，所以即使函数运行结束，这个静态变量的值也不会被销毁，函数下次使用时仍能用到这个值。

* 修饰函数

函数前加static使得函数成为静态函数，指函数的作用域仅限于本文件(内部函数)。而不用担心自己定义的函数是否会与其他文件中的函数同名。

**const**

类型修饰符，表示只读变量，具有不可变性。

```c
const int max = 100;
const int a[] = {1, 2};

//注意
const int *p; //p可变， p指向的对象不可变
int const *p; //p可变， p指向的对象不可变
int * const p; //p不可变，p指向的对象可变
const int * const p; //指针和指针指向的对象都不可变
```

**void**

空类型，`void *`可以指向任何类型的数据。

```c
//修饰函数返回值和参数
//函数没有返回值
void add(int a, int b)
//函数无参数
int func(void)

//void指针，如函数参数和返回值都是任意类型的指针
void *memcpy(void *buffer, int c)

//void不能代表一个真实的变量
void a; //错误
```

**extern**

可以置于变量或函数前，以表明变量或函数的定义在别的文件中，以下代码用到的变量或函数是外来的，不是本文件定义。

## 预处理

**宏定义**

define宏定义的数据没有类型，且它只是做简单的替换。

```c
// 数值宏定义
#define PI 3.14

//字符串宏定义, 尤其是路径
#define PATH E:\english\word

//定义表达式
#define num 6*6
#define sum(x) (x) + (x)

//注意函数宏被调用时是以实参代替形参，而非值传递。
sum(2) * sum(3) // 结果为2+3*2+3，解决方法是在定义时不要吝惜括号
//更改
#define sum(x) ((x)+(x))

//函数宏的调用不能缺少参数，如果有参数的话
#define add(a, b) (a + b)
add(3) //出错
```

**条件编译**

按不同的条件去编译不同的程序部分，而产生不同的目标代码文件，提高程序的可移植性。

```c
//A为表达式
//ifdef, else, elif, endif
#define A
#ifdef A
程序段1
#else
程序段2
#endif

//宏定义，不初始化。
//多用于文件引入，目的是避免被重复引用造成编译出错
#ifndef _NAME_H_INCLUDED_ //若该定义不存在，则编译以下内容
#define _NAME_H_INCLUDED_

//内容

#endif
```

**文件包含**

```c
//c编译系统提供
#include <name.h>
//导入当前目录自定文件
#include "name.h" //include是将已存在文件内容嵌入到当前文件中
//include支持相对路径，如"../file/name.h"
```

## 函数

函数不能返回数组，因为函数里声明的变量是局部变量，函数执行完就被销毁。替代方法是使用malloc动态分配内存，然后返回指针即可。
函数可返回除数组以外的其他类型如结构体。

## 内存管理

**堆**

malloc或new等分配的内存。其生命周期由free或delete决定。未释放前一直存在直到程序结束。

**栈**

保存局部变量，栈上的内容只在函数的范围内存在，函数运行结束这些内容自动被销毁。

**静态区**

保存全局变量和static变量，它在整个程序的生命周期内存在，由编译器编译时分配。

## issue

* 如何避免同样的数据结构类型，只是结构中存储了不同的数据类型，而重复定义处理函数。(使用void *p ??)
* 判断是否为数组
* 判断数组中元素类型
* 求数组长度



